<script type="text/javascript">
	"use strict";
	
	var searchDone = false;
	
    $(document).ready(function () {
		loadSettings(false, false);
		$('#tag-display').tagsinput({
			itemValue: 'value',
			itemText: 'text',
			tagClass: function(item) {
				switch (item.type) {
					case 'tag'   : return 'label label-primary';
					case 'category'  : return 'label label-danger label-important';
					case 'dungeon': return 'label label-success';
					//case 'Africa'   : return 'label label-default';
					case 'race'     : return 'label label-warning';
				}
			}
		});
		$('.bootstrap-tagsinput input').attr("readonly", true);
		$(".search-changer").change(function () {
			var type = $(this).attr("data-type");
			var value = $(this).val();
			var text = $("option:selected", this).text()
            $('#tag-display').tagsinput('add', { text: text, value: value, type: type });
			$(this).val("");
        });
		$('#search-amount').change(function () {
            saveSetting("searchAmount" + $('#search-view').val(), $(this).val());
			if (searchDone)
				handleSearch();
        });
		$('#search-view').change(function () {
			$('#search-amount').val(getSetting("searchAmount" + $(this).val()));
			saveSetting("searchView", $(this).val());
			if (searchDone)
				handleSearch();
        });
		$('#search-view').val(getSetting("searchView"));
		$('#search-amount').val(getSetting("searchAmount" + $("#search-view").val()));
		// Page should be loaded after search.
        var page = $(location).attr('href').split("#");
        if (page.length > 1) {
            page = page[1];
			$("#search-name").val(page.replace(/\+/g, ' '));
            handleSearch();
			// Search doesn't block the site from loading so don't add any code below.
        }
    });

// Track current search ID to stop previous search if use overwrites. / 2015-10-11 / Wethospu
var currentSearchID = 0;

// Attempts to find dungeon, path and category from parameters. Data must match all of these.
// Rest of the parameters are considered as a partial names. Data must contain at least one parameter.
function handleSearch() {
	$("#search-page").html("");
	setHash($("#search-name").val().replace(/\ /g, '+'));
	var names = $("#search-name").val().toLowerCase().split(" ");
	loadSettings(false, false);
	var searchObject = readParameters();
	currentSearchID = currentSearchID + 1;
	searchIndex(currentSearchID, names, dungeonsToPaths(searchObject.dungeons), searchObject.categories, searchObject.races, searchObject.tags, $("#search-amount").val());
	searchDone = true;
}

function readParameters() {
	var tagArray = $("#tag-display").tagsinput('items');
	if (tagArray == null)
		return { dungeons: [], categories: [], races: [], tags: [] };
	var dungeons = [];
	var races = [];
	var categories = [];
	var tags = [];
	// Separate tags.
	for (var i = 0; i < tagArray.length; i++) {
		if (tagArray[i].type == "dungeon")
			dungeons.push(tagArray[i].value);
		if (tagArray[i].type == "race")
			races.push(tagArray[i].value);
		if (tagArray[i].type == "category")
		{
			var value = tagArray[i].value;
			// Special categories.
			if (value == "boss")
			{
				if (categories.indexOf("champion") == -1)
					categories.push("champion");
				if (categories.indexOf("legendary") == -1)
					categories.push("legendary");
			}
			else if (value == "thrash")
			{
				if (categories.indexOf("normal") == -1)
					categories.push("normal");
				if (categories.indexOf("veteran") == -1)
					categories.push("veteran");
				if (categories.indexOf("elite") == -1)
					categories.push("elite");
			}
			else
				categories.push(value);
		}
			
		if (tagArray[i].type == "tag")
			tags.push(tagArray[i].value);
	}
	return {
        dungeons: dungeons,
        categories: categories,
		races: races,
		tags: tags
    };  
}

function dungeonsToPaths(dungeons) {
	var newDungeons = new Array();
	for (var i = 0; i < dungeons.length; i++) {
		if (dungeons[i] == "fotm")
		    newDungeons.push("insta", "aether", "aqua", "cliff", "furn", "mai", "molten", "snow", "solid", "swamp", "thauma", "uncat", "under", "urban", "volc");
		else if (dungeons[i] == "ta")
			newDungeons.push("tas", "taf", "taae", "tau");
		else {
			newDungeons.push(dungeons[i] + "s", dungeons[i] + "1", dungeons[i] + "2", dungeons[i] + "3");
			if (dungeons[i] == "arah")
				newDungeons.push("arah4");
		}
	}
	return newDungeons;
}

// Performance: Takes up to 250 ms.
function searchIndex(searchID, parameters, paths, categories, races, tags, resultCount) {
	var resultsTop = new Array();
	var resultsHigh = new Array();
	var resultsMedium = new Array();
	var resultsLow = new Array();
	var index = $("<div />");
	$(index).load("enemies/indexfile.htm", function () {
		var lines = $(index).html().split("\n");
		// Filter lines.
		for (var i = 0; i < lines.length; i++)
		{
			// Ignore comments.
			if (lines[i][0] == '<')
				continue;
			// display name|search name|category|dungeon|path|index
			var elements = lines[i].split("|");
			if (elements.length < 7)
				continue;
			// Check category.
			if (categories.length > 0 && categories.indexOf(elements[2]) == -1)
				continue;
			// Check race.
			if (races.length > 0 && races.indexOf(elements[3]) == -1)
				continue;
			// Check paths.
			var elementPaths = elements[4].split(":");
			var match = paths.length == 0;
			for (var j = 0; j < elementPaths.length; j++) {
				if (paths.indexOf(elementPaths[j]) > -1) {
					match = true;
					break;
				}
			}
			if (!match)
				continue;
			// Check tags (all must exist!).
			if ($(elements[6].split('')).filter(tags).length != tags.length)
				continue;
			// Check name for relevancy.
			var namesArray = elements[1].split("_");
			var exactMatches = 0;
			var partialMatches = 0;
			for (var j = 0; j < parameters.length; j++) {
				var param = parameters[j];
				for (var k = 0; k < namesArray.length; k++) {
					var name = namesArray[k];
					if (param == name)
					{
						exactMatches++;
						break;
					}
					if (name.indexOf(param) > -1)
					{
						partialMatches++;
						break;
					}
				}
			}
			if (exactMatches == parameters.length && parameters.length == namesArray.length)
				resultsTop.push(lines[i]);
			else if (exactMatches + partialMatches == parameters.length)
				resultsHigh.push(lines[i]);
			else if (exactMatches > 0)
				resultsMedium.push(lines[i]);
			else if (partialMatches > 0)
				resultsLow.push(lines[i]);
			else
				continue;
		}
		// Take only most relevant.
		var results = new Array();
		var size = resultsTop.length;
		if (size > resultCount)
			size = resultCount;
		results.push.apply(results, resultsTop.splice(0, size));
		resultCount -= size;
		if (resultCount > 0)
		{
			size = resultsHigh.length;
			if (size > resultCount)
				size = resultCount;
			results.push.apply(results, resultsHigh.splice(0, size));
			resultCount -= size;
			if (resultCount > 0) {
				size = resultsMedium.length;
				if (size > resultCount)
					size = resultCount;
				results.push.apply(results, resultsMedium.splice(0, size));
				resultCount -= size;
				if (resultCount > 0) {
					size = resultsLow.length;
					if (size > resultCount)
						size = resultCount;
					results.push.apply(results, resultsLow.splice(0, size));
					resultCount -= size;
				}
			}
		}
		results = processResults(results);
		
		if (results.length == 0) {
			$("#search-page").html("Found " + results.length + " results.");
			$("#instructions").css("display", "initial");
		}	
		else
		{
			if (results.length > 99)
				$("#search-page").html("Found " + results.length + " results. Please wait, this may take a while.");
			else
				$("#search-page").html("Found " + results.length + " results.");
			$("#instructions").css("display", "none");
			var htmlList = [];
			displayResults(searchID, 0, results, htmlList);
		}
		
	}).error(function (jqXHR, textStatus, errorThrown) {
		console.log("error " + textStatus);
		console.log("incoming Text " + jqXHR.responseText);
	});
}

// Converts a list of index file rows to a better data format. / 2015-08-12 / Wethospu
function processResults(results) {
	var elements = [];
	
	for (var i = 0; i < results.length; i++) {
		var dataArray = results[i].split("|");
		var element = {
			display: dataArray[0],
			category: dataArray[2],
			index: dataArray[5],
			order: i
		};
		elements.push(element);
	 }
	 elements.sort(function(a,b) {return a.dungeon == b.dungeon ? a.index - b.index : (a.dungeon > b.dungeon ? 1 : -1);} );
	 return elements;
}

// Finds found enemies from content files and displays them.
// Note: Load is asynchonous. This means we have to use recursive callback way instead of a loop.
// Performance: Takes up to 3000 ms if enemy pages not cached. Otherwise up to 500 ms.
function displayResults(searchID, elementID, elements, htmlList) {
	if (currentSearchID != searchID)
		return;
	// Check is this the last call.
	if (elementID >= elements.length) {
		// Build the html.
		var html = "";
		for (var i = 0; i < htmlList.length; i++)
			html += htmlList[i];
		// Display them.
		$("#search-page").html("Found " + htmlList.length + " results.");
		$("#search-page").append(html);
		applyEnemySettings("main");
		loadPage();
		return;
	}
	var view = $("#search-view").val();
	var numberToFind = elements[elementID].index;
	var fileNumber = Math.floor(numberToFind / 100);
	numberToFind -= fileNumber * 100;
	var fileDiv = $("<div />");
	$(fileDiv).load('enemies/enemies' + fileNumber + '.htm', function () {	
		// Find enemies.
		var counter = -1;
		$(fileDiv).find(".enemy").each(function () {
			counter++;
			if (counter != numberToFind)
				return;
			// Build enemy link.
			var str = '';
			if (view != "All" && view != "Info")
				str = '<span class="' + elements[elementID].category + ' enemy-button" data-index="' + elements[elementID].index + '"><h3>' + elements[elementID].display + '</h3></span>\n';
			if (view == "Info") {
				$(this).find("div").remove(":not(.in-line)");
				$(this).find("p").remove("p");
				$(this).find(".enemy-name").html('<span class="' + elements[elementID].category + ' enemy-button" data-index="' + elements[elementID].index + '">' + elements[elementID].display + '</span>');
			}
			if (view == "All" || view == "Info")	
				str += '<br/>\n' + $(this)[0].outerHTML;
			str += '\n<br/><hr/>\n';
			htmlList[elements[elementID].order] = str;
			// Check whether enemy can be found.
			elementID++;
			if (elementID >= elements.length)
				return;
			numberToFind = elements[elementID].index;
			if (fileNumber != Math.floor(numberToFind / 100))
				return;
			numberToFind -= fileNumber * 100;
		});
		displayResults(searchID, elementID, elements, htmlList);
	}).error(function (jqXHR, textStatus, errorThrown) {
		console.log("error " + textStatus);
		console.log("incoming Text " + jqXHR.responseText);
	});
}

</script>
<br>
<label for="search-name">Name</label>
<input id="search-name" type="text">
<button type="button" onclick="handleSearch()">Search</button>
<br><br>
<label for="tag-display">Active filters</label>
<select multiple id="tag-display" readonly>
</select>
<br>
<ul class="list-inline">
	<li>
		<select id="search-path" class="search-changer form-control" data-type="dungeon">
			<option value ="">Dungeon</option>
ID_PATHS
		</select>
	</li>
	<li>
		<select id="search-category" class="search-changer form-control" data-type="category">
			<option value ="">Category</option>
ID_CATEGORIES
		</select>
	</li>
	<li>
		<select id="search-race" class="search-changer form-control" data-type="race">
			<option value ="">Race</option>
ID_RACES
		</select>
	</li>
	<li>
		<select id="search-tag" class="search-changer form-control" data-type="tag">
			<option value ="">Tag</option>
ID_TAGS
		</select>
	</li>
	<li>
		<select id="search-effect-tag" class="search-changer form-control" data-type="tag">
			<option value ="">Effect tag</option>
ID_EFFECT_TAGS
		</select>
	</li>
</ul>
<br>
<ul class="list-inline">
	<li>
		<label for="search-view">Display</label>
		<select id="search-view" class="form-control">
			<option value="Name">Only name</option>
			<option value="Info">Some information</option>
			<option value="All">Everything</option>
		</select>
	</li>
	<li>
		<label for="search-amount">Results</label>
		<select id="search-amount" class="form-control">
			<option value="10000">Unlimited</option>
			<option value="100">100</option>
			<option value="10">10</option>
		</select>
	</li>
</ul>

<div id="search-page"></div>
<div id="instructions">
	<p>Filter results by selecting options from dropdowns. Active filters are displayed on "Filters". You can remove filters by clicking on the "x" button on them.</p>
	<p>Different type of filters are colored differently. Green is for dungeons, red is for categories, orange is for races and blue is for both tags.</p>
	<p>Tag and effect tag filters are exclusive. Enemies must match all active tags. Dungeon, category and race are inclusive. If multiple same type is active enemies must match only one of them.</p>
	<p>You can change amount of displayed information and results by changing view and results dropdowns. Amount of results automatically changes when you change amount of displayed information based on your previous selection.</p>
</div>
